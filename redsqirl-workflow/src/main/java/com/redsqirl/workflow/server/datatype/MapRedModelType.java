package com.redsqirl.workflow.server.datatype;

import java.rmi.RemoteException;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

import org.apache.hadoop.fs.Path;

import com.idiro.hadoop.checker.HdfsFileChecker;
import com.idiro.utils.RandomString;
import com.redsqirl.utils.FeatureList;
import com.redsqirl.workflow.utils.LanguageManagerWF;

public class MapRedModelType extends MapRedDir {

	/**
	 * 
	 */
	private static final long serialVersionUID = -2256801373086895177L;

	private String delimiter = new String(new char[] { '\001' });

	public MapRedModelType() throws RemoteException {
		super();
	}

	public MapRedModelType(FeatureList features) throws RemoteException {
		super(features);
	}

	@Override
	public String getTypeName() throws RemoteException {
		return "MODEL DETAILS DIRECTORY";
	}

	@Override
	public String[] getExtensions() throws RemoteException {
		return new String[] { "*.rsmodel" };
	}

	/**
	 * Gernate a path given values
	 * 
	 * @param userName
	 * @param component
	 * @param outputName
	 * @return generated path
	 * @throws RemoteException
	 */
	@Override
	public String generatePathStr(String userName, String component,
			String outputName) throws RemoteException {
		return "/user/" + userName + "/tmp/redsqirl_" + component + "_"
				+ outputName + "_" + RandomString.getRandomName(8) + ".rsmodel";
	}

	@Override
	public String isPathValid() throws RemoteException {
		String error = null;
		HdfsFileChecker hCh = new HdfsFileChecker(getPath());
		if (!hCh.isInitialized() || hCh.isFile()) {
			error = LanguageManagerWF.getText("mapredtexttype.dirisfile");
		} else {
			hCh.setPath(new Path(getPath()).getParent());
			if (!hCh.isDirectory()) {
				error = LanguageManagerWF.getText("mapredtexttype.nodir",new String[]{getPath()});
			}
			if(isPathExists()){
				hCh.setPath(new Path(getPath(), "output"));
				if (!hCh.isFile()) {
					error = LanguageManagerWF.getText("mapredmodeltype.nooutput");
				}
				hCh.setPath(new Path(getPath(), "_output"));
				if (!hCh.isFile()) {
					error = LanguageManagerWF.getText("mapredmodeltype.no_output");
				}
			}

		}
		// hCh.close();
		return error;
	}

	@Override
	public boolean isPathAutoGeneratedForUser(String userName,
			String component, String outputName) throws RemoteException {
		return getPath().startsWith(
				"/user/" + userName + "/tmp/redsqirl_" + component + "_"
						+ outputName + "_");
	}

	@Override
	public List<Map<String, String>> select(int maxToRead)
			throws RemoteException {
		List<Map<String, String>> ans = new LinkedList<Map<String, String>>();
		String patternStr = Pattern.quote(delimiter);
		Iterator<String> it = selectLine(maxToRead).iterator();
		while (it.hasNext()) {
			String l = it.next();
			String[] line = l.split(patternStr, -1);
			List<String> featureNames = getFeatures().getFeaturesNames();
			if (featureNames.size() == line.length) {
				Map<String, String> cur = new LinkedHashMap<String, String>();
				for (int i = 0; i < line.length; ++i) {
					cur.put(featureNames.get(i), line[i]);
				}
				ans.add(cur);
			} else {
				logger.error("The line size (" + line.length
						+ ") is not compatible to the number of features ("
						+ featureNames.size() + ").");
				logger.error("Error line: " + l);
				ans = null;
				break;
			}
		}
		return ans;
	}

	/**
	 * Set the path
	 * 
	 * @param path
	 * @throws RemoteException
	 */
	@Override
	public void setPath(String path) throws RemoteException {
		String oldPath = getPath();

		if (path == null) {
			super.setPath(path);
			setFeatures(null);
			return;
		}

		if (!path.equalsIgnoreCase(oldPath)) {

			super.setPath(path);

			logger.info("setPath() " + path);
			if (isPathExists()) {

				FeatureList fl = generateFeaturesMap(delimiter);

				String error = null;
				String header = getProperty(key_header);
				if (header != null && !header.isEmpty()) {
					logger.info("setFeaturesFromHeader --");
					error = setFeaturesFromHeader();
					if (error != null) {
						throw new RemoteException(error);
					}
				} else {
					if (features != null) {
						logger.debug(features.getFeaturesNames());
						logger.debug(fl.getFeaturesNames());
					} else {
						features = fl;
					}
				}

				if (features.getSize() != fl.getSize()) {
					if (header != null && !header.isEmpty()) {
						error = LanguageManagerWF
								.getText("mapredtexttype.setheaders.wronglabels");
					}
					features = fl;
				} else {
					Iterator<String> flIt = fl.getFeaturesNames().iterator();
					Iterator<String> featIt = features.getFeaturesNames()
							.iterator();
					boolean ok = true;
					int i = 1;
					while (flIt.hasNext() && ok) {
						String nf = flIt.next();
						String of = featIt.next();
						logger.info("types feat " + i + ": "
								+ fl.getFeatureType(nf) + " , "
								+ features.getFeatureType(of));
						ok &= canCast(fl.getFeatureType(nf),
								features.getFeatureType(of));
						if (!ok) {
							error = LanguageManagerWF.getText(
									"mapredtexttype.msg_error_cannot_cast",
									new Object[] { fl.getFeatureType(nf),
											features.getFeatureType(of) });
						}
						++i;
					}
					if (!ok) {
						features = fl;
						if (error != null) {
							throw new RemoteException(error);
						}
					}
				}

			}
		}

	}

	@Override
	protected String getDefaultColor() {
		return "DarkGoldenRod";
	}

}