package idiro.workflow.server.datatype;

import idiro.hadoop.NameNodeVar;
import idiro.hadoop.checker.HdfsFileChecker;
import idiro.utils.FeatureList;
import idiro.utils.RandomString;
import idiro.workflow.utils.LanguageManagerWF;

import java.io.IOException;
import java.rmi.RemoteException;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

import org.apache.hadoop.fs.FileStatus;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.fs.PathFilter;

public class MapRedCtrlATextType extends MapRedDir{

	/**
	 * 
	 */
	private static final long serialVersionUID = -2256801373086895177L;

	
	private String delimiter = new String(new char[]{'\001'});
	
	public MapRedCtrlATextType() throws RemoteException {
		super();
	}
	
	public MapRedCtrlATextType(FeatureList features) throws RemoteException {
		super(features);
	}

	@Override
	public String getTypeName() throws RemoteException {
		return "CTRL-A SEPARATED TEXT MAP-REDUCE DIRECTORY";
	}
	
	@Override
	public String[] getExtensions() throws RemoteException {
		return new String[]{"*.mrctra"};
	}

	/**
	 * Gernate a path given values
	 * 
	 * @param userName
	 * @param component
	 * @param outputName
	 * @return generated path
	 * @throws RemoteException
	 */
	@Override
	public String generatePathStr(String userName, String component,
			String outputName) throws RemoteException {
		return "/user/" + userName + "/tmp/idm_" + component + "_" + outputName
				+ "_" + RandomString.getRandomName(8)+".mrctra";
	}

	@Override
	public String isPathValid() throws RemoteException {
		String error = null;
		HdfsFileChecker hCh = new HdfsFileChecker(getPath());
		if (!hCh.isInitialized() || hCh.isFile()) {
			error = LanguageManagerWF.getText("mapredtexttype.dirisfile");
		} else {
			FileSystem fs;
			try {
				fs = NameNodeVar.getFS();
				hCh.setPath(new Path(getPath()));
				if (!hCh.isDirectory()) {
					error = LanguageManagerWF.getText("mapredtexttype.nodir");
				}
				FileStatus[] stat = fs.listStatus(new Path(getPath()),
						new PathFilter() {

					@Override
					public boolean accept(Path arg0) {
						return !arg0.getName().startsWith("_");
					}
				});
				for (int i = 0; i < stat.length && error == null; ++i) {
					if (stat[i].isDir()) {
						error = LanguageManagerWF.getText(
								"mapredtexttype.notmrdir",
								new Object[] { getPath() });
					} else {
						try {
							hdfsInt.select(stat[i].getPath().toString(),"", 1);
						} catch (Exception e) {
							error = LanguageManagerWF
									.getText("mapredtexttype.notmrdir");
						}
					}
				}
				try {
					// fs.close();
				} catch (Exception e) {
					logger.error("Fail to close FileSystem: " + e);
				}
			} catch (IOException e) {

				error = LanguageManagerWF.getText("unexpectedexception",
						new Object[] { e.getMessage() });

				logger.error(error);
			}

		}
		// hCh.close();
		return error;
	}

	@Override
	public boolean isPathAutoGeneratedForUser(String userName,
			String component, String outputName) throws RemoteException {
		return getPath().startsWith(
				"/user/" + userName + "/tmp/idm_" + component + "_"
						+ outputName + "_");
	}

	@Override
	public List<Map<String, String>> select(int maxToRead)
			throws RemoteException {
		List<Map<String,String>> ans = new LinkedList<Map<String,String>>();
		String patternStr = Pattern.quote(delimiter);
		Iterator<String> it = selectLine(maxToRead).iterator();
		while(it.hasNext()){
			String l = it.next();
			String[] line = l.split(patternStr,-1);
			List<String> featureNames = getFeatures().getFeaturesNames(); 
			if(featureNames.size() == line.length){
				Map<String,String> cur = new LinkedHashMap<String,String>();
				for(int i = 0; i < line.length; ++i){
					cur.put(featureNames.get(i),line[i]);
				}
				ans.add(cur);
			}else{
				logger.error("The line size ("+line.length+
						") is not compatible to the number of features ("+featureNames.size()+").");
				logger.error("Error line: "+l);
				ans = null;
				break;
			}
		}
		return ans;
	}
	
	/**
	 * Set the path
	 * 
	 * @param path
	 * @throws RemoteException
	 */
	@Override
	public void setPath(String path) throws RemoteException {
		String oldPath = getPath();

		if (path == null) {
			super.setPath(path);
			setFeatures(null);
			return;
		}

		if (!path.equalsIgnoreCase(oldPath)) {

			super.setPath(path);

			logger.info("setPath() " + path);
			if (isPathExists()) {

				FeatureList fl = generateFeaturesMap(delimiter);

				String error = null;
				String header = getProperty(key_header);
				if (header != null && !header.isEmpty()) {
					logger.info("setFeaturesFromHeader --");
					error = setFeaturesFromHeader();
					if (error != null) {
						throw new RemoteException(error);
					}
				} else {
					if (features != null) {
						logger.debug(features.getFeaturesNames());
						logger.debug(fl.getFeaturesNames());
					} else {
						features = fl;
					}
				}

				if (features.getSize() != fl.getSize()) {
					if (header != null && !header.isEmpty()) {
						error = LanguageManagerWF
								.getText("mapredtexttype.setheaders.wronglabels");
					}
					features = fl;
				} else {
					Iterator<String> flIt = fl.getFeaturesNames().iterator();
					Iterator<String> featIt = features.getFeaturesNames()
							.iterator();
					boolean ok = true;
					int i = 1;
					while (flIt.hasNext() && ok) {
						String nf = flIt.next();
						String of = featIt.next();
						logger.info("types feat " + i + ": "
								+ fl.getFeatureType(nf) + " , "
								+ features.getFeatureType(of));
						ok &= canCast(fl.getFeatureType(nf),
								features.getFeatureType(of));
						if (!ok) {
							error = LanguageManagerWF.getText(
									"mapredtexttype.msg_error_cannot_cast",
									new Object[] { fl.getFeatureType(nf),
											features.getFeatureType(of) });
						}
						++i;
					}
					if (!ok) {
						features = fl;
						if (error != null) {
							throw new RemoteException(error);
						}
					}
				}

			}
		}

	}

	@Override
	protected String getDefaultColor() {
		return "Brown";
	}

}