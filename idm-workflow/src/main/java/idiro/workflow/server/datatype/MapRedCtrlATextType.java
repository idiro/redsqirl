package idiro.workflow.server.datatype;

import idiro.hadoop.NameNodeVar;
import idiro.hadoop.checker.HdfsFileChecker;
import idiro.utils.FeatureList;
import idiro.utils.RandomString;
import idiro.workflow.utils.LanguageManagerWF;

import java.io.IOException;
import java.rmi.RemoteException;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

import org.apache.hadoop.fs.FileStatus;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.fs.PathFilter;

public class MapRedCtrlATextType extends MapRedDir{

	/**
	 * 
	 */
	private static final long serialVersionUID = -2256801373086895177L;

	public MapRedCtrlATextType() throws RemoteException {
		super();
	}
	
	public MapRedCtrlATextType(FeatureList features) throws RemoteException {
		super(features);
	}

	@Override
	public String getTypeName() throws RemoteException {
		return "CTRL-A DELIMITED TEXT MAP-REDUCE DIRECTORY";
	}

	/**
	 * Gernate a path given values
	 * 
	 * @param userName
	 * @param component
	 * @param outputName
	 * @return generated path
	 * @throws RemoteException
	 */
	@Override
	public String generatePathStr(String userName, String component,
			String outputName) throws RemoteException {
		return "/user/" + userName + "/tmp/idm_" + component + "_" + outputName
				+ "_" + RandomString.getRandomName(8)+".mrctra";
	}

	@Override
	public String isPathValid() throws RemoteException {
		String error = null;
		HdfsFileChecker hCh = new HdfsFileChecker(getPath());
		if (!hCh.isInitialized() || hCh.isFile()) {
			error = LanguageManagerWF.getText("mapredtexttype.dirisfile");
		} else {
			FileSystem fs;
			try {
				fs = NameNodeVar.getFS();
				hCh.setPath(new Path(getPath()));
				if (!hCh.isDirectory()) {
					error = LanguageManagerWF.getText("mapredtexttype.nodir");
				}
				FileStatus[] stat = fs.listStatus(new Path(getPath()),
						new PathFilter() {

					@Override
					public boolean accept(Path arg0) {
						return !arg0.getName().startsWith("_");
					}
				});
				for (int i = 0; i < stat.length && error == null; ++i) {
					if (stat[i].isDir()) {
						error = LanguageManagerWF.getText(
								"mapredtexttype.notmrdir",
								new Object[] { getPath() });
					} else {
						try {
							hdfsInt.select(stat[i].getPath().toString(),"", 1);
						} catch (Exception e) {
							error = LanguageManagerWF
									.getText("mapredtexttype.notmrdir");
						}
					}
				}
				try {
					// fs.close();
				} catch (Exception e) {
					logger.error("Fail to close FileSystem: " + e);
				}
			} catch (IOException e) {

				error = LanguageManagerWF.getText("unexpectedexception",
						new Object[] { e.getMessage() });

				logger.error(error);
			}

		}
		// hCh.close();
		return error;
	}

	@Override
	public boolean isPathAutoGeneratedForUser(String userName,
			String component, String outputName) throws RemoteException {
		return getPath().startsWith(
				"/user/" + userName + "/tmp/idm_" + component + "_"
						+ outputName + "_");
	}

	@Override
	public List<Map<String, String>> select(int maxToRead)
			throws RemoteException {
		List<Map<String,String>> ans = new LinkedList<Map<String,String>>();
		String patternStr = Pattern.quote(new String(new char[]{'\001'}));
		Iterator<String> it = selectLine(maxToRead).iterator();
		while(it.hasNext()){
			String l = it.next();
			String[] line = l.split(patternStr,-1);
			List<String> featureNames = getFeatures().getFeaturesNames(); 
			if(featureNames.size() == line.length){
				Map<String,String> cur = new LinkedHashMap<String,String>();
				for(int i = 0; i < line.length; ++i){
					cur.put(featureNames.get(i),line[i]);
				}
				ans.add(cur);
			}else{
				logger.error("The line size ("+line.length+
						") is not compatible to the number of features ("+featureNames.size()+").");
				logger.error("Error line: "+l);
				ans = null;
				break;
			}
		}
		return ans;
	}

	@Override
	protected String getDefaultColor() {
		return "Brown";
	}

}
