
What is a package
	
	Packages are a group of actions that are used in IDM to perform specific processes on IDM. 
	They generally run on the same platform , e.g,. Pig , Hive 
	etc. This how IDM mudualarises its functionalities and manages what is available for the users.

What is in a  Package

	A Package will contain actions that can be used on IDM once the package is installed. 
	An action will have two files that are required , these are the help and image files.
	
Create a package


 [[1]]Step 1

	Create new project as maven give a group id and an artifact id

	Edit pom to add necessary dependencies and configuration for packaging the package 
	

+---+
<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<main.pck>${project.build.directory}/${project.artifactId}-${project.version}/</main.pck>
		<target.pck>src/main/pck</target.pck>
		<maven.build.timestamp.format>yyyy-MM-dd</maven.build.timestamp.format>
		<timestamp>${maven.build.timestamp}</timestamp>
		<pck-repo>${basedir}/src/main/pck-repo</pck-repo>
		<target.pck-repo>${basedir}/target/pck-repo-${project.artifactId}-${project.version}</target.pck-repo>
	</properties>

	<distributionManagement>
		<repository>
			<id>internal</id>
			<name>Internal Release Repository</name>
			<url>scp://dev.local.net/var/www/html/apache-archiva-1.3.6/data/repositories/internal</url>
		</repository>

		<snapshotRepository>
			<id>snapshots</id>
			<name>Internal Snapshot Repository</name>
			<url>scp://dev.local.net/var/www/html/apache-archiva-1.3.6/data/repositories/snapshots</url>
		</snapshotRepository>
	</distributionManagement>

	<organization>
		<name>Idiro Technologies</name>
		<url>http://www.idiro.com</url>
	</organization>

	<reporting>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-project-info-reports-plugin</artifactId>
				<version>2.6</version>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-javadoc-plugin</artifactId>
				<version>2.9</version>
				<configuration>
				</configuration>
			</plugin>
		</plugins>
	</reporting>

	<build>

		<extensions>
			<extension>
				<groupId>org.apache.maven.wagon</groupId>
				<artifactId>wagon-ssh</artifactId>
				<version>1.0</version>
			</extension>
		</extensions>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.1</version>
				<configuration>
					<source>1.6</source>
					<target>1.6</target>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-jar-plugin</artifactId>
				<version>2.3.1</version>
				<configuration>
					<outputDirectory>${main.pck}/lib/</outputDirectory>
				</configuration>
			</plugin>

			<plugin>
				<groupId>com.google.code.maven-replacer-plugin</groupId>
				<artifactId>replacer</artifactId>
				<version>1.5.2</version>
				<executions>
					<execution>
						<id>create-pck-repo-sql</id>
						<phase>package</phase>
						<goals>
							<goal>replace</goal>
						</goals>
						<configuration>
							<file>${pck-repo}/record_repo.sql</file>
							<outputFile>${target.pck-repo}/record_repo.sql</outputFile>
							<replacements>
								<replacement>
									<token>#{ARTIFACTID}</token>
									<value>${project.artifactId}</value>
								</replacement>
								<replacement>
									<token>#{NAME}</token>
									<value>${project.name}</value>
								</replacement>
								<replacement>
									<token>#{DESCRIPTION}</token>
									<value>${project.description}</value>
								</replacement>
								<replacement>
									<token>#{VERSION}</token>
									<value>${project.version}</value>
								</replacement>
								<replacement>
									<token>#{TIMESTAMP}</token>
									<value>${timestamp}</value>
								</replacement>
							</replacements>
							<regex>false</regex>
						</configuration>
					</execution>
					<execution>
						<id>create-pck-repo-html</id>
						<phase>package</phase>
						<goals>
							<goal>replace</goal>
						</goals>
						<configuration>
							<file>${pck-repo}/idm-hama.html</file>
							<outputFile>${target.pck-repo}/${project.artifactId}-${project.version}.html</outputFile>
							<replacements>
								<replacement>
									<token>#{ARTIFACTID}</token>
									<value>${project.artifactId}</value>
								</replacement>
								<replacement>
									<token>#{NAME}</token>
									<value>${project.name}</value>
								</replacement>
								<replacement>
									<token>#{DESCRIPTION}</token>
									<value>${project.description}</value>
								</replacement>
								<replacement>
									<token>#{VERSION}</token>
									<value>${project.version}</value>
								</replacement>
								<replacement>
									<token>#{TIMESTAMP}</token>
									<value>${timestamp}</value>
								</replacement>
							</replacements>
							<regex>false</regex>
						</configuration>
					</execution>
				</executions>
			</plugin>


			<plugin>
				<artifactId>maven-resources-plugin</artifactId>
				<version>2.6</version>
				<executions>
					<execution>
						<id>copy-resources</id>
						<phase>package</phase>
						<goals>
							<goal>copy-resources</goal>
						</goals>
						<configuration>
							<outputDirectory>${main.pck}</outputDirectory>
							<resources>
								<resource>
									<directory>${target.pck}</directory>
									<filtering>true</filtering>
								</resource>
							</resources>
						</configuration>
					</execution>
				</executions>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-assembly-plugin</artifactId>
				<version>2.4</version>
				<executions>
					<execution>
						<id>zip_pck</id> 
						<phase>package</phase> 
						<goals>
							<goal>single</goal>
						</goals>
						<configuration>
							<finalName>${project.artifactId}-${project.version}</finalName>
							<appendAssemblyId>false</appendAssemblyId>
							<outputDirectory>${target.pck-repo}</outputDirectory>
							<descriptors>
								<descriptor>src/main/assembly/zip_pck.xml</descriptor>
							</descriptors>
						</configuration>
					</execution>
					<execution>
						<id>zip_repo</id> 
						<phase>package</phase> 
						<goals>
							<goal>single</goal>
						</goals>
						<configuration>
							<finalName>pck-repo-${project.artifactId}-${project.version}</finalName>
							<appendAssemblyId>false</appendAssemblyId>
							<outputDirectory>${project.build.directory}</outputDirectory>
							<descriptors>
								<descriptor>src/main/assembly/zip_repo.xml</descriptor>
							</descriptors>
						</configuration>
					</execution>
				</executions>
			</plugin>
		</plugins>
	</build>

	<dependencies>

		<dependency>
			<groupId>idiro</groupId>
			<artifactId>idm-wf-interface</artifactId>
			<version>${project.version}</version>
			<scope>compile</scope>
		</dependency>
		<dependency>
			<groupId>idiro</groupId>
			<artifactId>idm-workflow</artifactId>
			<version>${project.version}</version>
			<scope>compile</scope>
		</dependency>

		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.11</version>
		</dependency>
		<dependency>
			<groupId>log4j</groupId>
			<artifactId>log4j</artifactId>
			<version>1.2.12</version>
			<scope>compile</scope>
		</dependency>

	</dependencies>

+--------------------------------------+
	* Create a new package under source main
	
	* Create an abstract class so it extends 'DataFlowAction'
	
	* For the purposes of the tutorial , this abstract class will be called 'DemoAction'
	
	These steps are the basic steps to create a project that will allow for development of a package that can be used in IDM

	<<Outcome:>> A project that contains an abstract class that will allow for creating new actions
	The skeleton of the project can be found here :  CREATE A LINK (1)

 [[2]]Step 2

	In the previous step we created a project that contains all the dependencies and an abstract class that will be the base class for the package.
	
	For this tutorial we will create the package so that it runs over Pig.
	To configure the package to run Pig processes  the 'DemoAction' the constructor must be 
	canged so that it calls the superclass construnctor with a 'new PigAction()'

+-----------+
public DemoAction() throws RemoteException {
		super(new PigAction());
	}
+-----------+

	Once the constructor has been implemented it is then important to add the essentials for every pig action that is created using the abstract class.
	In Pig script each line that performs an action is assigned to a 'Bag'. In this class we will create an integer that increments everytime a new bag is created.
	With this integer we will have two methods that get the current bag and one to get the next one.
	
+-----------+
private int bagNum = 0;
+-----------+

	The functions that uses it.

+-----------+
protected String getCurrentName(){
		return "A"+bagNum;
	}
protected String getNextName(){
		bagNum++;
		return "A"+bagNum;
	}
+-----------+

	An action can have many inputs, to accommodate the inputs ,  we implement a Map that will store the input and a name asocciated with it.
	We also make a function that returns this map for reading later.
	
+-----------+
protected Map<String, DFELinkProperty> input;
public Map<String, DFELinkProperty> getInput() throws RemoteException {
		return input;
	}
+-----------+

	To make things easier for further development of other actions it may be easier to use key string to access parts of the input or output and other aspects
	of the action. Here is a list of key string that might be useful
	
+-----------+
public static final String
key_output = "",
key_input = "in",
key_delimiter="delimiter",
key_condition = "condition",
key_outputType = "output_type",
default_delimiter = "\001",
key_featureTable = "features";
+-----------+
 
	

	Every action generates an ouput, so we need to make sure that there is a map ready to be used which will contain the output.
	For this we update thw map to have the right type of output and properties for that output.
	
+-----------+
public String updateOut() throws RemoteException {
		String error = checkIntegrationUserVariables();
		if(error == null){
			FeatureList new_features = getNewFeatures();
			if(output.get(key_output) == null){
				output.put(key_output, new MapRedTextType());
			}
			output.get(key_output).setFeatures(new_features);
			output.get(key_output).addProperty(MapRedTextType.key_delimiter, delimiterOutputInt.getValue());
		}
		return error;
	}
+-----------+
	
	In every action of Pig it is necessary to set the output type and the delimiter. Pig accepts two types of output which is either text or binary.
	This means we need two interactions just for the output.

+-----------+
protected InputInteraction delimiterOutputInt;
protected ListInteraction savetypeOutputInt;	
+-----------+

	With the input and the outputs configured and updated (output) we can look at the initial methods for the action.
	The init method actually initialized the input.
	
+-----------+
protected void init(int nbInMin, int nbInMax) throws RemoteException{
		if(input == null){
			Map<String, DFELinkProperty> in = new LinkedHashMap<String, DFELinkProperty>();
			in.put(key_input, new DataProperty(MapRedBinaryType.class, nbInMin, nbInMax));
			input = in;
		}
	}
+-----------+
	
	The features that available on initialization can be different from the output of the action. We have to create two methods to get the input features and the output features.
	
+-----------+
public abstract FeatureList getInFeatures() throws RemoteException;
public abstract FeatureList getNewFeatures() throws RemoteException;
+-----------+
	

	

	An important method that needs to be added is one to generate the query for the entire action for this we add an abstract method that gets the query.
	When an action calls this method it will call all the interactions that it contains to get their part of the query.
	
+-----------+
public abstract String getQuery() throws RemoteException;
+-----------+

	There are a few more functions that are important for creating a query. These functions are common between all Pig Actions, 
	like get the query piece for reading the data with the correct read function with the attributes with correct data types , getting the piece
	that writes the result of the query with the right storage function and delimter. They are listed below:
	 

	Remove the output directory before running the query
	 
+-----------+
public String getRemoveQueryPiece(String out) throws RemoteException{
		logger.debug("create remove...");
		return "rmf "+out;
	}
+-----------+

	Get the load or storage function for the data

+-----------+
private String getLoadStoreFuncion(DFEOutput out, String delimiter) throws RemoteException{
		String function = null;
		if (out.getTypeName().equals("TEXT MAP-REDUCE DIRECTORY")){
			function = "PigStorage('"+delimiter+"')";
		}
		else if (out.getTypeName().equals("BINARY MAP-REDUCE DIRECTORY")){
			function = "BinStorage()";
		}
		return function;
	}
+-----------+

	Get the variable to load with the variable types and return as a string

+-----------+
public String getLoadQueryPiece(DFEOutput out) throws RemoteException{
	logger.debug("create load...");

	String delimiter = out.getProperty(MapRedTextType.key_delimiter);
	delimiter = ((MapRedTextType)out).getPigDelimiter();
	if (delimiter == null){
		delimiter = default_delimiter;
	}

	String function = getLoadStoreFuncion(out, delimiter);
	String createSelect = "LOAD '" + out.getPath() + "' USING "+function+" as (";

	Iterator<String> it = out.getFeatures().getFeaturesNames().iterator();
	logger.info("attribute list size : "+out.getFeatures().getSize());
	while (it.hasNext()){
		String e = it.next();
		createSelect += e+":"+PigTypeConvert.getPigType(out.getFeatures().getFeatureType(e));
		if (it.hasNext()){
			createSelect += ", ";
		}
	}
	createSelect +=")";

	return createSelect;
	}
+-----------+

	Get the query piece to store the results

+-----------+
public String getStoreQueryPiece(DFEOutput out, String relationName) throws RemoteException{
		MapRedTextType output = (MapRedTextType) getDFEOutput().get(key_output); 
		String delimiter = output.getPigDelimiter();

		String function = getStoreFunction(delimiter);
		logger.info(function);
		return "STORE "+relationName+" INTO '" + out.getPath() + "' USING "+function+";";
	}
+-----------+

	Get the storage function that pig should use to store the result with the correct delimiter
	
+-----------+
public String getStoreFunction(String delimiter) throws RemoteException{
		String type = "";
		String function = "";
		if(delimiter==null || delimiter.equalsIgnoreCase("")){
			delimiter ="|";
		}
		try{
			type = savetypeOutputInt.getTree().getFirstChild("list").getFirstChild("output").getFirstChild().getHead();
			logger.info("type: "+type);
			if(type.equalsIgnoreCase("TEXT MAP-REDUCE DIRECTORY")){
				function = "PigStorage('"+delimiter+"')";
			}
			if (type.equalsIgnoreCase("BINARY MAP-REDUCE DIRECTORY")){
				function = "BinStorage()";
			}
			logger.info("Storing via "+function);
			return function;
		}catch (Exception e){
			logger.error("There was an error getting the output type");
		}
		return null;

	}
+-----------+

	So far we have added functionality for the common query pieces for pig actions , bag numner handling and getting the intput and output maps aswel as updating the output map.
	As IDM runs through Oozie it is important for each action to write their process so that it is comaptible with Oozie. 
	For this all that needs to be done is to implement the 'writeOozieActionFiles(File[] files)' method. This method 
	
+-----------+
public boolean writeOozieActionFiles(File[] files) throws RemoteException {
		logger.info("Write queries in file: "+files[0].getAbsolutePath());
		String toWrite = getQuery();
		boolean ok = toWrite != null;
		if(ok){
			logger.info("Content of "+files[0].getName()+": "+toWrite);
			try {
				FileWriter fw = new FileWriter(files[0]);
				BufferedWriter bw = new BufferedWriter(fw);
				bw.write(toWrite);	
				bw.close();

			} catch (IOException e) {
				ok = false;
				logger.error("Fail to write into the file "+files[0].getAbsolutePath());
			}
		}
		return ok;
	}
+-----------+
	
	Now that everything is is configured and we have all that is neccessary for a basic action lets take another look at the constructor.
	As the two interaction mentioned earlier for configuring the output is common for all pig actions we can implement them in the constructor as
	all actionsion will have to call the superclass construnctor ('DemoAction') as it set the Oozie action type to be a Pig Action. The following code is 
	
+-----------+
public DemoAction() throws RemoteException {
		super(new PigAction());
		init(1,1);

		delimiterOutputInt = new InputInteraction(
				key_delimiter,
				"Pig Delimiter",
				"Set the delimiter character for the  ", 
				0, 0);
		delimiterOutputInt.setRegex("^(#\\d{1,3}|.)?$");
		delimiterOutputInt.setValue("#1");


		savetypeOutputInt = new ListInteraction(
				key_outputType,
				"Pig Output Type",
				"Set the Pig output type of the action", 1, 0);
		savetypeOutputInt.setDisplayRadioButton(true);
		List<String> saveTypePos = new LinkedList<String>();
		saveTypePos.add( new MapRedTextType().getTypeName());
		saveTypePos.add( new MapRedBinaryType().getTypeName());
		savetypeOutputInt.setPossibleValues(saveTypePos);
		savetypeOutputInt.setValue(new MapRedTextType().getTypeName());
	}
+-----------+

	<<Outcome:>> Project with abstract class complete ready for use.
	The skeleton of the project can be found here :  CREATE A LINK (1)

 [[3]]Step 3

	Now that we have the abstract class that is implemented with the essentials we can now look at implementing our first action.
	That action that we are going to implement is sample. Pig has an action that allows for sampling the data and all that is needed
	is the size at which you sample.
	
	Let's identify the methods that we need to implement.
	
	This method simply returns the name of the method
	
+-----------+
	public String getName() throws RemoteException {
		
		return "sample";
	}
+-----------+

	This methods simple returns the features that are available from the input.

+-----------+
	@Override
	public FeatureList getInFeatures() throws RemoteException {
		return getDFEInput().get(DemoAction.key_input).get(0).getFeatures();
	}
+-----------+

	This method returns the new features generated from the action , as the action we are implementing is only to sample there should be no new features.
	Here we simply return the input features.
	
+-----------+
	@Override
	public FeatureList getNewFeatures() throws RemoteException {
		return getInFeatures();
	}
+-----------+

	Once these methods are implemented , let's implement the only interaction that we need which will inherit from 'InputInteraction'.
	We still have two methods to implement and the constructor to finish but it is necessary to implement the interaction first.
	
	So create a new package for interactions and add a new class called 'SampleInteraction'.
	Once 'SampleInteraction' has been created we should have a constuctor that looks like the code below.
	
+-----------+

+-----------+

	
	

