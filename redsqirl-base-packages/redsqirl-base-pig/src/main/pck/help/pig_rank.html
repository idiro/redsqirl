
<!DOCTYPE html>
<html>
<head>
<title>Pig Rank Help</title>

</head>
<body>
	<h1>Pig Rank</h1>
	<h2>Decription</h2>
	<p>Pig Rank is an action that allows data to be 
		ranked.</p>
	<h3>Quick Guide</h3>
	<p>
	<ul>
		<li>Input
			<ul>
				<li><a class="stopLink" id="helpmain_canvas"
					onclick="return false;" href="../help/canvas.html#output_type">
						Text or Binary Map Reduce Directory </a></li>
			</ul>
		</li>
		<li>Configurations
			<ul>
				<li>Rank - Set the fields for the data set to be ranked by</li>
				<li>Order - Set order of the field to be ranked</li>
				<li>Filter the entire data set by setting a condition</li>
				<li>Choose data format</li>
			</ul>
		</li>
		<li>Output
			<ul>
				<li><a class="stopLink" id="helpmain_canvas"
					onclick="return false;" href="../help/canvas.html#output_type">
						Text or Binary Map Reduce Directory </a></li>
			</ul>
		</li>
	</ul>
	</p>

	<h2>
		<a id="page1">Ranking - Page 2</a>
	</h2>

	<h3>Rank</h3>
	
	<p>Select a field to rank the dataset by. This will order the
		dataset by this field and also rank it by the selected field.</p>
	<h2>
	
	<h3>Order</h3>
	<p>Set the order in which the ranking is performed</p>
		<a id="page2">Filtering, Formating and Auditing - Page 3</a>
	</h2>

	<h3>Filter</h3>
	<p>Set filters to filter out the row of interest. The
		filter is applied row per row indepently. The query can be as
		complicated or as complex as needed.</p>

	<h3>Delimiter</h3>

	<p>Choose the delimiter character used to separate the output
		dataset field in each row. The delimiter is used only if you choose
		Text format.</p>
	<h3>Format</h3>

	<ul>
		<li>Text: save the result in a text format which is user
			readable, very handy for re-using the output</li>
		<li>Binary: Use pig binary format. Binary format for reading and
			writing is a bit faster than a text format.</li>
	</ul>



	<h2>Red Sqirl Pig</h2>
	<p>
		Red Sqirl Pig is a package that contains actions that interface with <a
			target="_blank" href="http://pig.apache.org/">Pig</a> on the Red
		Sqirl platform to perform Pig actions. The pig actions available from
		the package are
	<ul>
		<li>Pig Aggregator</li>
		<li>Pig Anonymise</li>
		<li>Pig Binary Source</li>
		<li>Pig Join</li>
		<li>Pig Sample</li>
		<li>Pig Select</li>
		<li>Pig Text Source</li>
		<li>Pig Transpose</li>
		<li>Pig Unanonymise</li>
		<li>Pig Union</li>
		<li>Pig Value Binning</li>
		<li>Pig Volume Binning</li>
		<li>Pig Group Rank</li>
		<li>Pig Rank</li>
	</ul>

	</p>

	<h3>Redsqirl Pig Data set</h3>

	<p>The last page of every pig action will have two interactions
		that set the output format of the pig action. These interactions are
		to set the delimiter of the file for a TEXT MAP REDUCE DIRECTORY and
		the other is to set the output type of the file to be either TEXT MAP
		REDUCE DIRECTORY or BINARY MAP-REDUCE DIRECTORY</p>

	<h3>Auditing</h3>

	<p>After each Pig action it is possible to audit the result in
		order to have a better idea of the data set and help make decisions on
		what to do next. For example you may want to do an audit before using
		a binning node in order to have an idea of your value range. Also
		result of the audit may create auto-generated options.</p>

	<h3>Apache Pig</h3>

	<p>Apache Pig is a platform for analyzing large data sets, which
		consists of a high-level language for expressing data analysis
		programs, coupled with infrastructure for evaluating these programs.
		The salient property of Pig programs is that their structure is
		amenable to substantial parallelization, which in turns enables them
		to handle very large data sets. At the present time, Pig's
		infrastructure layer consists of a compiler that produces sequences of
		Map-Reduce programs, for which large-scale parallel implementations
		already exist (e.g., the Hadoop subproject). Pig's language layer
		currently consists of a textual language called Pig Latin, which has
		the following key properties:
	<ul>
		<li>Ease of programming. It is trivial to achieve parallel
			execution of simple, "embarrassingly parallel" data analysis tasks.
			Complex tasks comprised of multiple interrelated data transformations
			are explicitly encoded as data flow sequences, making them easy to
			write, understand, and maintain.</li>
		<li>Optimization opportunities. The way in which tasks are
			encoded permits the system to optimize their execution automatically,
			allowing the user to focus on semantics rather than efficiency.</li>
		<li>Extensibility. Users can create their own functions to do
			special-purpose processing.</li>
	</ul>
	</p>
</body>
</html>

